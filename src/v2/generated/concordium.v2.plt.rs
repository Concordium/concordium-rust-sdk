// This file is @generated by prost-build.
/// A Cbor encoded bytestring
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CBor {
    /// A CBOR encoded byte string.
    #[prost(bytes = "vec", tag = "1")]
    pub value: ::prost::alloc::vec::Vec<u8>,
}
/// The unique symbol and identifier of a protocol level token.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TokenId {
    /// Unique identifier for the token, guaranteed to be distinct across the
    /// entire concordium blockchain.
    #[prost(string, tag = "1")]
    pub symbol: ::prost::alloc::string::String,
}
/// A token module reference. This is always 32 bytes long.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TokenModuleRef {
    #[prost(bytes = "vec", tag = "1")]
    pub value: ::prost::alloc::vec::Vec<u8>,
}
/// PLT amount representation. The actual amount is computed as `digits *
/// 10^(-nr_of_decimals)`.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TokenAmount {
    /// The digits of the amount.
    #[prost(uint64, tag = "1")]
    pub digits: u64,
    /// Number of decimals in the representation
    #[prost(uint32, tag = "2")]
    pub nr_of_decimals: u32,
}
/// Token state at the block level
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TokenState {
    /// The reference of the module implementing this token.
    #[prost(message, optional, tag = "1")]
    pub token_module_ref: ::core::option::Option<TokenModuleRef>,
    /// Account address of the issuer. The issuer is the holder of the nominated
    /// account which can perform token-governance operations.
    #[prost(message, optional, tag = "2")]
    pub issuer: ::core::option::Option<super::AccountAddress>,
    /// Number of decimals in the decimal number representation of amounts.
    #[prost(uint32, tag = "3")]
    pub nr_of_decimals: u32,
    /// The total available token supply.
    #[prost(message, optional, tag = "4")]
    pub total_supply: ::core::option::Option<TokenAmount>,
    /// Token module specific state, such as token name, feature flags, meta data.
    #[prost(message, optional, tag = "5")]
    pub module_state: ::core::option::Option<CBor>,
}
/// Token state at the account level
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TokenAccountState {
    /// The available balance.
    #[prost(message, optional, tag = "1")]
    pub balance: ::core::option::Option<TokenAmount>,
    /// Whether the account is a member of the allow list of the token.
    /// If present, tokens can be transferred only, if both sender and receiver are
    /// members of the allow list of the token.
    #[prost(bool, optional, tag = "2")]
    pub member_allow_list: ::core::option::Option<bool>,
    /// Whether the account is a member of the deny list of the token.
    /// If present, tokens can be transferred only, if neither sender or receiver
    /// are members of the deny list.
    #[prost(bool, optional, tag = "3")]
    pub member_deny_list: ::core::option::Option<bool>,
}
/// Single token event originating as part of a token governance transaction.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TokenGovernanceEvent {
    /// The unique token symbol.
    #[prost(message, optional, tag = "1")]
    pub token_symbol: ::core::option::Option<TokenId>,
    /// The type of the event.
    #[prost(string, tag = "2")]
    pub r#type: ::prost::alloc::string::String,
    /// The CBOR encoded event details.
    #[prost(message, optional, tag = "3")]
    pub details: ::core::option::Option<CBor>,
}
/// Token events originating from token governance transactions.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TokenGovernanceEffect {
    /// Events emitted by the token.
    #[prost(message, repeated, tag = "1")]
    pub events: ::prost::alloc::vec::Vec<TokenGovernanceEvent>,
}
/// Single token event originating as part of a token holder transaction.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TokenHolderEvent {
    /// The unique token symbol.
    #[prost(message, optional, tag = "1")]
    pub token_symbol: ::core::option::Option<TokenId>,
    /// The type of the event.
    #[prost(string, tag = "2")]
    pub r#type: ::prost::alloc::string::String,
    /// The CBOR encoded event details.
    #[prost(message, optional, tag = "3")]
    pub details: ::core::option::Option<CBor>,
}
/// Token events originating from token holder transactions.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TokenHolderEffect {
    /// Events emitted by the token.
    #[prost(message, repeated, tag = "1")]
    pub events: ::prost::alloc::vec::Vec<TokenHolderEvent>,
}
