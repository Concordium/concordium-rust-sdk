//! Higher-level abstraction for interactions with
//! Protocol Level Tokens (PLT). Contains [`TokenClient`] that implements PLT
//! operations as its methods.
//!
//! Using the [`TokenClient`] is functionally equivalent to using the mid-level
//! abstractions in [`operations`].

use concordium_base::{
    base::Nonce,
    common::{cbor::CborSerializationError, types::TransactionTime},
    contracts_common::AccountAddress,
    hashes::TransactionHash,
    protocol_level_tokens::{operations, TokenAmount, TokenId, TokenOperations},
    transactions::{send, BlockItem},
};
use thiserror::Error;

use crate::{
    protocol_level_tokens::{CborMemo, TokenInfo},
    types::WalletAccount,
    v2::{AccountIdentifier, BlockIdentifier, Client, IntoBlockIdentifier, QueryError, RPCError},
};

/// A wrapper around the gRPC client representing a PLT, which
/// provides functions for interaction with a specific PLT.
///
/// Note that cloning is cheap and is, therefore, the intended way of sharing
/// this type between multiple tasks.
#[derive(Debug, Clone)]
pub struct TokenClient {
    /// an actual gRPC client used for fetching data.
    client:         Client,
    /// the state of the token upon initialization for this struct.
    info:           TokenInfo,
    /// default expiration time.
    default_expiry: u32,
}

/// Optional paramters for a transaction.
#[derive(Debug, Default)]
pub struct TransactionMetadata {
    /// Optional expiration time for the transaction.
    pub expiry:   Option<TransactionTime>,
    /// Optional nonce for the transactions. Autogenerated if None.
    pub nonce:    Option<Nonce>,
    /// Optional flag for validating payloads. If None - no extra
    /// check.
    pub validate: Option<bool>,
}

/// Higher-level representation of the PLT transfer
#[derive(Debug, Clone)]
pub struct TransferTokens {
    /// The amount of tokens to transfer.
    pub amount:    TokenAmount,
    /// The recipient account.
    pub recipient: AccountAddress,
    /// An optional memo.
    pub memo:      Option<CborMemo>,
}

/// Result of a Token operation.
/// This is an alias for [std::Result](https://doc.rust-lang.org/std/result/enum.Result.html) that fixes the error type to be [`TokenError`].
pub type TokenResult<T> = Result<T, TokenError>;

/// Enum representing the types of errors that can occur when interacting with
/// PLT instances through the client.
#[derive(Debug, Error)]
pub enum TokenError {
    /// Errors that can occur when making queries.
    #[error("Query error: {0}")]
    Query(#[from] QueryError),
    /// Error that can occur during serializing or deserializing CBOR
    #[error("Cbor serialization/deserializing error: {0}")]
    CborSerialization(#[from] CborSerializationError),
    /// Error that can occur over RPC.
    #[error("RPC error: {0}")]
    RPC(#[from] RPCError),
    /// Error type indicating the supplied token amount is not compatible with
    /// the token.
    #[error("The token amount supplied cannot be represented as an amount of the token.")]
    InvalidTokenAmount,
    /// Error representing an attempt to transfer tokens from an account that
    /// does not have enough tokens to cover the amount.
    #[error("The sender has insufficient funds.")]
    InsufficientFunds,
    /// Error representing attempt to transfer funds to an account which is
    /// either not on the token allow list, or is on the token deny list
    #[error(
        "Transfering funds from or to the account is currently not allowed because of the \
         allow/deny list."
    )]
    NotAllowed,
    /// Error type indicating an unauthorized governance operation was
    /// attempted.
    #[error("Unauthorized governance operation attempted")]
    UnauthorizedGovernanceOperation,
    /// Error that indicates that provided payload for raw operations does not
    /// match with the client's token ID.
    #[error("Invalid token ID in the provided payload.")]
    InvalidTokenId,
    /// Error that indicates insufficient balance in the governance account to
    /// burn the total amount in the payload.
    #[error("Total token amount in the payload exceeds governance account balance.")]
    InsufficientSupply,
    #[error("The token state is paused")]
    Paused,
}

impl TokenClient {
    /// Construct a [`TokenClient`] from existing RPC client and [TokenInfo].
    /// Has a default transaction expiration time set to 5 minutes.
    ///
    /// # Arguments
    ///
    /// * `client` - The RPC client for the concordium node.
    /// * `info` - [`TokenInfo`] of an exiting PLT.
    pub fn new(client: Client, info: TokenInfo) -> Self {
        let default_expiry = 300;
        Self {
            client,
            info,
            default_expiry,
        }
    }

    /// A helper methods for fetching the token info.
    pub fn token_info(&self) -> &TokenInfo { &self.info }

    /// Construct a [`TokenClient`] by looking up metadata from the chain
    /// (such as the token info). Has a default transaction expiration time set
    /// to 5 minutes.
    ///
    /// # Arguments
    ///
    /// * `client` - The RPC client for the concordium node.
    /// * `token_id` - The ID of the token.
    pub async fn init_from_token_id(mut client: Client, token_id: TokenId) -> TokenResult<Self> {
        let info = client
            .get_token_info(token_id, BlockIdentifier::LastFinal)
            .await?
            .response;
        let default_expiry = 300;

        Ok(Self {
            client,
            info,
            default_expiry,
        })
    }

    /// Suspends execution of any operation involving balance changes for the
    /// token.
    ///
    /// # Arguments
    ///
    /// * `signer` - A [`WalletAccount`] who's address is used as a sender and
    ///   keys as a signer.
    /// * `meta` - The optional transaction metadata. Includes optional
    ///   expiration, nonce, and validation.
    pub async fn pause(
        &mut self,
        signer: &WalletAccount,
        meta: Option<TransactionMetadata>,
    ) -> TokenResult<TransactionHash> {
        let TransactionMetadata { expiry, nonce, .. } = meta.unwrap_or_default();

        let operations = [operations::pause()].into_iter().collect();
        self.sign_and_send(signer, operations, expiry, nonce).await
    }

    /// Resumes execution of any operation involving balance changes for the
    /// token.
    ///
    /// # Arguments
    ///
    /// * `signer` - A [`WalletAccount`] who's address is used as a sender and
    ///   keys as a signer.
    /// * `meta` - The optional transaction metadata. Includes optional
    ///   expiration, nonce, and validation.
    pub async fn unpause(
        &mut self,
        signer: &WalletAccount,
        meta: Option<TransactionMetadata>,
    ) -> TokenResult<TransactionHash> {
        let TransactionMetadata { expiry, nonce, .. } = meta.unwrap_or_default();

        let operations = [operations::unpause()].into_iter().collect();
        self.sign_and_send(signer, operations, expiry, nonce).await
    }

    /// Transfers [`TokenAmount`]s from the sender to the specified recipients.
    ///
    /// # Arguments
    ///
    /// * `signer` - A [`WalletAccount`] who's address is used as a sender and
    ///   keys as a signer.
    /// * `payload` - The transfer payload.
    /// * `meta` - The optional transaction metadata. Includes optional
    ///   expiration, nonce, and validation. Check [Self::validate_transfer] for
    ///   the list of validations.
    pub async fn transfer(
        &mut self,
        signer: &WalletAccount,
        payload: Vec<TransferTokens>,
        meta: Option<TransactionMetadata>,
    ) -> TokenResult<TransactionHash> {
        let TransactionMetadata {
            expiry,
            nonce,
            validate,
        } = meta.unwrap_or_default();

        if let Some(validate) = validate {
            if validate {
                self.validate_transfer(signer.address, payload.clone())
                    .await?;
            }
        }

        let operations: TokenOperations = payload
            .into_iter()
            .map(|tr| {
                let receiver = tr.recipient;
                match tr.memo {
                    Some(memo) => operations::transfer_tokens_with_memo(receiver, tr.amount, memo),
                    None => operations::transfer_tokens(receiver, tr.amount),
                }
            })
            .collect();

        self.sign_and_send(signer, operations, expiry, nonce).await
    }

    /// Mints a specified amount of tokens.
    ///
    /// # Arguments
    ///
    /// * `signer` - a [`WalletAccount`] who's address is used as a sender and
    ///   keys as a signer.
    /// * `amount` - The amount of tokens to mint.
    /// * `meta` - The optional transaction metadata. Includes optional
    ///   expiration, nonce, and validation.
    pub async fn mint(
        &mut self,
        signer: &WalletAccount,
        amount: TokenAmount,
        meta: Option<TransactionMetadata>,
    ) -> TokenResult<TransactionHash> {
        let TransactionMetadata {
            expiry,
            nonce,
            validate,
        } = meta.unwrap_or_default();

        if let Some(validate) = validate {
            if validate {
                // checks if the token is not paused
                if self
                    .info
                    .token_state
                    .decode_module_state()?
                    .paused
                    .unwrap_or_default()
                {
                    return Err(TokenError::Paused);
                }

                // check if amount to be minted has the same decimals as the token.
                if amount.decimals() != self.info.token_state.decimals {
                    return Err(TokenError::InvalidTokenAmount);
                }
            }
        }
        let operations = [operations::mint_tokens(amount)].into_iter().collect();

        self.sign_and_send(signer, operations, expiry, nonce).await
    }

    /// Burns a specified amount of tokens.
    ///
    /// # Arguments
    ///
    /// * `signer` - A [`WalletAccount`] who's address is used as a sender and
    ///   keys as a signer.
    /// * `amount` - The amount of tokens to burn.
    /// * `meta` - The optional transaction metadata. Includes optional
    ///   expiration, nonce, and validation.
    pub async fn burn(
        &mut self,
        signer: &WalletAccount,
        amount: TokenAmount,
        meta: Option<TransactionMetadata>,
    ) -> TokenResult<TransactionHash> {
        let TransactionMetadata {
            expiry,
            nonce,
            validate,
        } = meta.unwrap_or_default();

        if let Some(validate) = validate {
            if validate {
                // checks if the token is not paused
                if self
                    .info
                    .token_state
                    .decode_module_state()?
                    .paused
                    .unwrap_or_default()
                {
                    return Err(TokenError::Paused);
                }

                // check if amount to be burned has the same decimals as the token.
                if amount.decimals() != self.info.token_state.decimals {
                    return Err(TokenError::InvalidTokenAmount);
                }

                // check if amount to be burned exceeds account's token amount in possesion
                let burnable_amount = self
                    .balance_of(&signer.address.into(), None::<BlockIdentifier>)
                    .await?
                    .ok_or(TokenError::InsufficientSupply)?;

                if burnable_amount.value() < amount.value() {
                    return Err(TokenError::InsufficientSupply);
                }
            }
        }
        let operations = [operations::burn_tokens(amount)].into_iter().collect();

        self.sign_and_send(signer, operations, expiry, nonce).await
    }

    /// Adds accounts to the allow list of a token.
    ///
    /// # Arguments
    ///
    /// * `signer` - A [`WalletAccount`] who's address is used as a sender and
    ///   keys as a signer.
    /// * `targets` - The account addresses to be added to the allow list.
    /// * `meta` - The optional transaction metadata. Includes optional
    ///   expiration, nonce, and validation.
    pub async fn add_allow_list(
        &mut self,
        signer: &WalletAccount,
        targets: Vec<AccountAddress>,
        meta: Option<TransactionMetadata>,
    ) -> TokenResult<TransactionHash> {
        let TransactionMetadata { expiry, nonce, .. } = meta.unwrap_or_default();

        let operations = targets
            .into_iter()
            .map(operations::add_token_allow_list)
            .collect();

        self.sign_and_send(signer, operations, expiry, nonce).await
    }

    /// Removes an accounts from the allow list of a token.
    ///     
    /// # Arguments
    ///
    /// * `signer` - A [`WalletAccount`] who's address is used as a sender and
    ///   keys as a signer.
    /// * `targets` - The account addresses to be removed from the allow list.
    /// * `meta` - The optional transaction metadata. Includes optional
    ///   expiration, nonce, and validation.
    pub async fn remove_allow_list(
        &mut self,
        signer: &WalletAccount,
        targets: Vec<AccountAddress>,
        meta: Option<TransactionMetadata>,
    ) -> TokenResult<TransactionHash> {
        let TransactionMetadata { expiry, nonce, .. } = meta.unwrap_or_default();

        let operations = targets
            .into_iter()
            .map(operations::remove_token_allow_list)
            .collect();

        self.sign_and_send(signer, operations, expiry, nonce).await
    }

    /// Adds an accounts to the deny list of a token.
    ///
    /// # Arguments
    ///
    /// * `signer` - A [`WalletAccount`] who's address is used as a sender and
    ///   keys as a signer.
    /// * `targets` - The account addresses to be added to the deny list.
    /// * `expiry` - The optional expiry time for the transaction.
    /// * `opts` - Options for the list update operation.
    /// * `meta` - The optional transaction metadata. Includes optional
    ///   expiration, nonce, and validation.
    pub async fn add_deny_list(
        &mut self,
        signer: &WalletAccount,
        targets: Vec<AccountAddress>,
        meta: Option<TransactionMetadata>,
    ) -> TokenResult<TransactionHash> {
        let TransactionMetadata { expiry, nonce, .. } = meta.unwrap_or_default();

        let operations = targets
            .into_iter()
            .map(operations::add_token_deny_list)
            .collect();

        self.sign_and_send(signer, operations, expiry, nonce).await
    }

    /// Removes an accounts from the deny list of a token.
    ///
    /// # Arguments
    ///
    /// * `signer` - A [`WalletAccount`] who's address is used as a sender and
    ///   keys as a signer.
    /// * `targets` - The account addresses to be removed from the deny list.
    /// * `meta` - The optional transaction metadata. Includes optional
    ///   expiration, nonce, and validation.
    pub async fn remove_deny_list(
        &mut self,
        signer: &WalletAccount,
        targets: Vec<AccountAddress>,
        meta: Option<TransactionMetadata>,
    ) -> TokenResult<TransactionHash> {
        let TransactionMetadata { expiry, nonce, .. } = meta.unwrap_or_default();

        let operations = targets
            .into_iter()
            .map(operations::remove_token_deny_list)
            .collect();

        self.sign_and_send(signer, operations, expiry, nonce).await
    }

    /// Retrieves the balance of a token for a given account.
    ///
    /// # Arguments
    ///
    /// * `acc` - The account who's balances must be fetched.
    /// * `bi` - The block identifier. Defaults to Last Final block, if
    ///   [`None`].
    pub async fn balance_of(
        &mut self,
        acc: &AccountIdentifier,
        bi: Option<impl IntoBlockIdentifier>,
    ) -> TokenResult<Option<TokenAmount>> {
        let bi = match bi {
            Some(bi) => bi.into_block_identifier(),
            None => BlockIdentifier::LastFinal,
        };

        let info = &self.client.get_account_info(acc, bi).await?.response;
        Ok(info.token_amount(&self.info.token_id))
    }

    /// Validates a token transfer.
    /// The method checks for:
    /// * The token is not in the paused state.
    /// * All [`TokenAmount`]s for the transfer have the same decimals as the
    ///   token.
    /// * The sender has sufficient funds for all transfers.
    /// * Neither sender nor all recievers are in the tokens deny list.
    /// * The sender and all recievers are in the tokens allow list.
    ///
    /// # Arguments
    ///
    /// * `sender` - The account address of the sender.
    /// * `payload` - The token transfers that are about to be sent.
    pub async fn validate_transfer(
        &mut self,
        sender: AccountAddress,
        payload: Vec<TransferTokens>,
    ) -> TokenResult<()> {
        if self
            .info
            .token_state
            .decode_module_state()?
            .paused
            .unwrap_or_default()
        {
            return Err(TokenError::Paused);
        }

        let decimals = self.info.token_state.decimals;

        // Validate all amounts
        if payload
            .iter()
            .any(|transfer| transfer.amount.decimals() != decimals)
        {
            return Err(TokenError::InvalidTokenAmount);
        }

        let sender_info = self
            .client
            .get_account_info(&sender.into(), BlockIdentifier::LastFinal)
            .await?
            .response;

        // Check the sender ballance
        let sender_balance = sender_info
            .token_amount(&self.info.token_id)
            .unwrap_or(TokenAmount::from_raw(0, decimals));

        let payload_total = TokenAmount::from_raw(
            payload
                .iter()
                .try_fold(0u64, |acc, x| acc.checked_add(x.amount.value()))
                .ok_or(TokenError::InvalidTokenAmount)?,
            decimals,
        );

        if payload_total > sender_balance {
            return Err(TokenError::InsufficientFunds);
        }

        // Check if token has no allow and deny lists
        let module_state = self.info.token_state.decode_module_state()?;
        if module_state.allow_list.is_none_or(|val| !val)
            && module_state.deny_list.is_none_or(|val| !val)
        {
            return Ok(());
        }

        // Check sender and recievers for allow and deny lists
        let mut accounts = Vec::with_capacity(payload.len() + 1);
        accounts.push(sender_info);

        let futures = payload.into_iter().map(|transfer| {
            let holder = transfer.recipient;
            let mut client = self.client.clone();
            async move {
                client
                    .get_account_info(&holder.into(), BlockIdentifier::LastFinal)
                    .await
            }
        });

        let recepients = futures::future::join_all(futures).await;
        for recepient in recepients {
            let info = recepient?.response;
            accounts.push(info);
        }

        for account in accounts {
            if let Some(token_state) = account
                .tokens
                .into_iter()
                .find(|t| t.token_id == self.info.token_id)
                .map(|t| t.state)
            {
                let account_module_state = token_state.decode_module_state()?;
                if module_state.deny_list.unwrap_or_default()
                    && account_module_state.deny_list.unwrap_or_default()
                {
                    return Err(TokenError::NotAllowed);
                }

                if module_state.allow_list.unwrap_or_default()
                    && !account_module_state.allow_list.unwrap_or_default()
                {
                    return Err(TokenError::NotAllowed);
                }
            }
        }
        Ok(())
    }

    /// Validates that the sender is authorized to perform governance operations
    /// on the token.
    ///
    /// # Arguments
    ///
    /// * `sender` - The account address of the sender.
    pub fn validate_governance_operation(&mut self, _sender: AccountAddress) -> TokenResult<()> {
        Ok(())
    }

    /// Initiates a transaction with a list of PLT operations for a given token.
    ///
    /// # Arguments
    ///
    /// * `signer` - A [`WalletAccount`] who's address is used as a sender and
    ///   keys as a signer.
    /// * `expiry` - The optional expiry time for the transaction.
    /// * `operations` - A list of protocol level token operations.
    /// * `meta` - The optional transaction metadata. Includes optional
    ///   expiration, nonce. Validation is ignored for this method.
    pub async fn send_operations(
        &mut self,
        signer: &WalletAccount,
        operations: TokenOperations,
        meta: Option<TransactionMetadata>,
    ) -> TokenResult<TransactionHash> {
        let TransactionMetadata { expiry, nonce, .. } = meta.unwrap_or_default();
        self.sign_and_send(signer, operations, expiry, nonce).await
    }

    /// Helper method containing the common logic related to signing and sending
    /// PLT operations.
    ///
    /// # Arguments
    ///
    /// * `signer` - A [`WalletAccount`] who's address is used as a sender and
    ///   keys as a signer.
    /// * `operations` - A list of protocol level token operations.
    /// * `expiry` - The expiry time for the transaction.
    /// * `nonce` - Option
    async fn sign_and_send(
        &mut self,
        signer: &WalletAccount,
        operations: TokenOperations,
        expiry: Option<TransactionTime>,
        nonce: Option<Nonce>,
    ) -> TokenResult<TransactionHash> {
        let expiry = expiry.unwrap_or(TransactionTime::seconds_after(self.default_expiry));

        let nonce = match nonce {
            Some(nonce) => nonce,
            None => {
                self.client
                    .get_next_account_sequence_number(&signer.address)
                    .await?
                    .nonce
            }
        };

        let token_id = self.info.token_id.clone();

        let transaction = send::token_update_operations(
            &signer,
            signer.address,
            nonce,
            expiry,
            token_id,
            operations,
        )?;
        let block_item = BlockItem::AccountTransaction(transaction);
        Ok(self.client.send_block_item(&block_item).await?)
    }
}
