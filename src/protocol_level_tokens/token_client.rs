//! Higher-level abstraction for interactions with
//! Protocol Level Tokens (PLT). Contains [`TokenClient`] that implements PLT
//! operations as its methods.
//!
//! Using the [`TokenClient`] is functionally equivalent to using the mid-level
//! abstractions in [`operations`].

use concordium_base::{
    base::Nonce,
    common::{cbor::CborSerializationError, types::TransactionTime},
    contracts_common::AccountAddress,
    hashes::TransactionHash,
    protocol_level_tokens::{operations, TokenAmount, TokenId, TokenModuleState, TokenOperations},
    transactions::{send, BlockItem},
};
use thiserror::Error;

use crate::{
    endpoints,
    protocol_level_tokens::{CborMemo, TokenAccountState, TokenInfo},
    types::{AccountInfo, WalletAccount},
    v2::{
        AccountIdentifier, BlockIdentifier, Client, IntoBlockIdentifier, QueryError, QueryResponse,
        RPCError,
    },
};

/// A wrapper around the gRPC client representing a PLT, which
/// provides functions for interaction with a specific PLT.
///
/// Note that cloning is cheap and is, therefore, the intended way of sharing
/// this type between multiple tasks.
#[derive(Debug, Clone)]
pub struct TokenClient {
    /// an actual gRPC client used for fetching data.
    client:         Client,
    /// the state of the token upon initialization for this struct.
    info:           TokenInfo,
    /// default expiration time.
    default_expiry: u32,
}

/// Optional paramters for a transaction.
#[derive(Debug, Default)]
pub struct TransactionMetadata {
    /// Optional expiration time for the transaction.
    pub expiry: Option<TransactionTime>,
    /// Optional nonce for the transactions. Autogenerated if None.
    pub nonce:  Option<Nonce>,
}

/// Whether to perform client side validation of PLT operations before
/// submitting transactions. The validation will fetch the necessary, latest
/// finalized state and perform validation based on that.
///
/// Notice that the option does not affect the validation performed by the node.
#[derive(Debug, Clone, Copy, Eq, PartialEq, Hash, Default)]
pub enum Validation {
    /// Do not perform any client side validation
    #[default]
    NoValidation,
    /// Fetch the necessary, latest finalized state and validate the PLT
    /// operation based on that
    Validate,
}

/// Higher-level representation of the PLT transfer
#[derive(Debug, Clone)]
pub struct TransferTokens {
    /// The amount of tokens to transfer.
    pub amount:    TokenAmount,
    /// The recipient account.
    pub recipient: AccountAddress,
    /// An optional memo.
    pub memo:      Option<CborMemo>,
}

/// Result of a Token operation.
/// This is an alias for [std::Result](https://doc.rust-lang.org/std/result/enum.Result.html) that fixes the error type to be [`TokenError`].
pub type TokenResult<T> = Result<T, TokenError>;

/// Enum representing the types of errors that can occur when interacting with
/// PLT instances through the client.
#[derive(Debug, Error)]
pub enum TokenError {
    /// Errors that can occur when making queries.
    #[error("query error: {0}.")]
    Query(#[from] QueryError),
    /// Error that can occur during serializing or deserializing CBOR
    #[error("qbor serialization/deserializing error: {0}.")]
    CborSerialization(#[from] CborSerializationError),
    /// Error that can occur over RPC.
    #[error("RPC error: {0}.")]
    RPC(#[from] RPCError),
    /// Error type indicating the supplied token amount is not compatible with
    /// the token.
    #[error("the token amount supplied cannot be represented as an amount of the token.")]
    InvalidTokenAmount,
    /// Error representing an attempt to transfer tokens from an account that
    /// does not have enough tokens to cover the amount.
    #[error("the sender has insufficient funds.")]
    InsufficientFunds,
    /// Error representing attempt to transfer funds to an account which is
    /// either not on the token allow list, or is on the token deny list
    #[error(
        "transfering funds from or to the account is currently not allowed because of the \
         allow/deny list."
    )]
    NotAllowed,
    /// Error that indicates that provided payload for raw operations does not
    /// match with the client's token ID.
    #[error("invalid token ID in the provided payload.")]
    InvalidTokenId,
    /// Error that indicates insufficient balance to burn the total amount in
    /// the payload.
    #[error("total token amount in the payload exceeds account's balance.")]
    InsufficientSupply,
    /// Error indicating that supply change operation is prohibited while the
    /// token is in the paused state.
    #[error("the token state is paused.")]
    Paused,
    /// Error that indicates that the token does not support minting.
    #[error("the token cannot be minted.")]
    NotMintable,
    /// Error that indicates that the token does not support burning.
    #[error("the token cannot be burned.")]
    NotBurnable,
    /// Error that indicates that allow list is not available for this token.
    #[error("the token does not have allow list.")]
    NoAllowList,
    /// Error that indicates that deny list is not available for this token.
    #[error("the token does not have deny list.")]
    NoDenyList,
}

impl TokenClient {
    /// Construct a [`TokenClient`] from existing RPC client and [TokenInfo].
    /// Has a default transaction expiration time set to 5 minutes.
    ///
    /// # Arguments
    ///
    /// * `client` - The RPC client for the concordium node.
    /// * `info` - [`TokenInfo`] of an exiting PLT.
    pub fn new(client: Client, info: TokenInfo) -> Self {
        let default_expiry = 300;
        Self {
            client,
            info,
            default_expiry,
        }
    }

    /// A helper methods for fetching the token info.
    pub fn token_info(&self) -> &TokenInfo { &self.info }

    /// Construct a [`TokenClient`] by looking up metadata from the chain
    /// (such as the token info). Has a default transaction expiration time set
    /// to 5 minutes.
    ///
    /// # Arguments
    ///
    /// * `client` - The RPC client for the concordium node.
    /// * `token_id` - The ID of the token.
    pub async fn init_from_token_id(mut client: Client, token_id: TokenId) -> TokenResult<Self> {
        let info = client
            .get_token_info(token_id, BlockIdentifier::LastFinal)
            .await?
            .response;
        let default_expiry = 300;

        Ok(Self {
            client,
            info,
            default_expiry,
        })
    }

    /// Suspends execution of any operation involving balance changes for the
    /// token.
    ///
    /// # Arguments
    ///
    /// * `signer` - A [`WalletAccount`] who's address is used as a sender and
    ///   keys as a signer.
    /// * `meta` - The optional transaction metadata. Includes optional
    ///   expiration, nonce, and validation.
    pub async fn pause(
        &mut self,
        signer: &WalletAccount,
        meta: Option<TransactionMetadata>,
    ) -> TokenResult<TransactionHash> {
        let TransactionMetadata { expiry, nonce, .. } = meta.unwrap_or_default();

        let operations = [operations::pause()].into_iter().collect();
        self.sign_and_send(signer, operations, expiry, nonce).await
    }

    /// Resumes execution of any operation involving balance changes for the
    /// token.
    ///
    /// # Arguments
    ///
    /// * `signer` - A [`WalletAccount`] who's address is used as a sender and
    ///   keys as a signer.
    /// * `meta` - The optional transaction metadata. Includes optional
    ///   expiration, nonce, and validation.
    pub async fn unpause(
        &mut self,
        signer: &WalletAccount,
        meta: Option<TransactionMetadata>,
    ) -> TokenResult<TransactionHash> {
        let TransactionMetadata { expiry, nonce, .. } = meta.unwrap_or_default();

        let operations = [operations::unpause()].into_iter().collect();
        self.sign_and_send(signer, operations, expiry, nonce).await
    }

    /// Transfers [`TokenAmount`]s from the sender to the specified recipients.
    ///
    /// # Arguments
    ///
    /// * `signer` - A [`WalletAccount`] who's address is used as a sender and
    ///   keys as a signer.
    /// * `payload` - The transfer payload.
    /// * `meta` - The optional transaction metadata. Includes optional
    ///   expiration and nonce.
    /// * `validation` - The flag for indicating whether to validate the
    ///   transaction against the latest finalized state. Check
    ///   [TokenClient::validate_transfer] for the list of validations.
    pub async fn transfer(
        &mut self,
        signer: &WalletAccount,
        payload: Vec<TransferTokens>,
        meta: Option<TransactionMetadata>,
        validation: Validation,
    ) -> TokenResult<TransactionHash> {
        if validation == Validation::Validate {
            self.validate_transfer(signer.address, payload.clone())
                .await?;
        }

        let TransactionMetadata { expiry, nonce } = meta.unwrap_or_default();

        let operations: TokenOperations = payload
            .into_iter()
            .map(|tr| {
                let receiver = tr.recipient;
                match tr.memo {
                    Some(memo) => operations::transfer_tokens_with_memo(receiver, tr.amount, memo),
                    None => operations::transfer_tokens(receiver, tr.amount),
                }
            })
            .collect();

        self.sign_and_send(signer, operations, expiry, nonce).await
    }

    /// Mints a specified amount of tokens.
    ///
    /// # Arguments
    ///
    /// * `signer` - a [`WalletAccount`] who's address is used as a sender and
    ///   keys as a signer.
    /// * `amount` - The amount of tokens to mint.
    /// * `meta` - The optional transaction metadata. Includes optional
    ///   expiration and nonce.
    /// * `validation` - The flag for indicating whether to validate the
    ///   transaction against the latest finalized state. Check
    ///   [TokenClient::validate_mint] for the list of validations.
    pub async fn mint(
        &mut self,
        signer: &WalletAccount,
        amount: TokenAmount,
        meta: Option<TransactionMetadata>,
        validation: Validation,
    ) -> TokenResult<TransactionHash> {
        if validation == Validation::Validate {
            self.validate_mint(amount).await?;
        }

        let TransactionMetadata { expiry, nonce } = meta.unwrap_or_default();

        let operations = [operations::mint_tokens(amount)].into_iter().collect();

        self.sign_and_send(signer, operations, expiry, nonce).await
    }

    /// Burns a specified amount of tokens.
    ///
    /// # Arguments
    ///
    /// * `signer` - A [`WalletAccount`] who's address is used as a sender and
    ///   keys as a signer.
    /// * `amount` - The amount of tokens to burn.
    /// * `meta` - The optional transaction metadata. Includes optional
    ///   expiration and nonce.
    /// * `validation` - The flag for indicating whether to validate the
    ///   transaction against the latest finalized state. Check
    ///   [TokenClient::validate_burn] for the list of validations.
    pub async fn burn(
        &mut self,
        signer: &WalletAccount,
        amount: TokenAmount,
        meta: Option<TransactionMetadata>,
        validation: Validation,
    ) -> TokenResult<TransactionHash> {
        if validation == Validation::Validate {
            self.validate_burn(amount, signer.address).await?;
        }

        let TransactionMetadata { expiry, nonce } = meta.unwrap_or_default();

        let operations = [operations::burn_tokens(amount)].into_iter().collect();

        self.sign_and_send(signer, operations, expiry, nonce).await
    }

    /// Adds accounts to the allow list of a token.
    ///
    /// # Arguments
    ///
    /// * `signer` - A [`WalletAccount`] who's address is used as a sender and
    ///   keys as a signer.
    /// * `targets` - The account addresses to be added to the allow list.
    /// * `meta` - The optional transaction metadata. Includes optional
    ///   expiration and nonce.
    /// * `validation` - The flag for indicating whether to validate the
    ///   transaction against the latest finalized state. Check
    ///   [TokenClient::validate_allow_list_update] for the list of validations.
    pub async fn add_allow_list(
        &mut self,
        signer: &WalletAccount,
        targets: Vec<AccountAddress>,
        meta: Option<TransactionMetadata>,
        validation: Validation,
    ) -> TokenResult<TransactionHash> {
        if validation == Validation::Validate {
            self.validate_allow_list_update().await?;
        }

        let TransactionMetadata { expiry, nonce } = meta.unwrap_or_default();

        let operations = targets
            .into_iter()
            .map(operations::add_token_allow_list)
            .collect();

        self.sign_and_send(signer, operations, expiry, nonce).await
    }

    /// Removes an accounts from the allow list of a token.
    ///     
    /// # Arguments
    ///
    /// * `signer` - A [`WalletAccount`] who's address is used as a sender and
    ///   keys as a signer.
    /// * `targets` - The account addresses to be removed from the allow list.
    /// * `meta` - The optional transaction metadata. Includes optional
    ///   expiration and nonce.
    /// * `validation` - The flag for indicating whether to validate the
    ///   transaction against the latest finalized state. Check
    ///   [TokenClient::validate_allow_list_update] for the list of validations.
    pub async fn remove_allow_list(
        &mut self,
        signer: &WalletAccount,
        targets: Vec<AccountAddress>,
        meta: Option<TransactionMetadata>,
        validation: Validation,
    ) -> TokenResult<TransactionHash> {
        if validation == Validation::Validate {
            self.validate_allow_list_update().await?;
        }

        let TransactionMetadata { expiry, nonce } = meta.unwrap_or_default();

        let operations = targets
            .into_iter()
            .map(operations::remove_token_allow_list)
            .collect();

        self.sign_and_send(signer, operations, expiry, nonce).await
    }

    /// Adds an accounts to the deny list of a token.
    ///
    /// # Arguments
    ///
    /// * `signer` - A [`WalletAccount`] who's address is used as a sender and
    ///   keys as a signer.
    /// * `targets` - The account addresses to be added to the deny list.
    /// * `expiry` - The optional expiry time for the transaction.
    /// * `opts` - Options for the list update operation.
    /// * `meta` - The optional transaction metadata. Includes optional
    ///   expiration and nonce.
    /// * `validation` - The flag for indicating whether to validate the
    ///   transaction against the latest finalized state. Check
    ///   [TokenClient::validate_deny_list_update] for the list of validations.
    pub async fn add_deny_list(
        &mut self,
        signer: &WalletAccount,
        targets: Vec<AccountAddress>,
        meta: Option<TransactionMetadata>,
        validation: Validation,
    ) -> TokenResult<TransactionHash> {
        if validation == Validation::Validate {
            self.validate_deny_list_update().await?;
        }

        let TransactionMetadata { expiry, nonce } = meta.unwrap_or_default();

        let operations = targets
            .into_iter()
            .map(operations::add_token_deny_list)
            .collect();

        self.sign_and_send(signer, operations, expiry, nonce).await
    }

    /// Removes an accounts from the deny list of a token.
    ///
    /// # Arguments
    ///
    /// * `signer` - A [`WalletAccount`] who's address is used as a sender and
    ///   keys as a signer.
    /// * `targets` - The account addresses to be removed from the deny list.
    /// * `meta` - The optional transaction metadata. Includes optional
    ///   expiration and nonce.
    /// * `validation` - The flag for indicating whether to validate the
    ///   transaction against the latest finalized state. Check
    ///   [TokenClient::validate_deny_list_update] for the list of validations.
    pub async fn remove_deny_list(
        &mut self,
        signer: &WalletAccount,
        targets: Vec<AccountAddress>,
        meta: Option<TransactionMetadata>,
        validation: Validation,
    ) -> TokenResult<TransactionHash> {
        if validation == Validation::Validate {
            self.validate_deny_list_update().await?
        }

        let TransactionMetadata { expiry, nonce } = meta.unwrap_or_default();

        let operations = targets
            .into_iter()
            .map(operations::remove_token_deny_list)
            .collect();

        self.sign_and_send(signer, operations, expiry, nonce).await
    }

    /// Retrieves the balance of a token for a given account.
    ///
    /// # Arguments
    ///
    /// * `acc` - The account who's balances must be fetched.
    /// * `bi` - The block identifier. Defaults to Last Final block, if
    ///   [`None`].
    pub async fn balance_of(
        &mut self,
        acc: &AccountIdentifier,
        bi: Option<impl IntoBlockIdentifier>,
    ) -> TokenResult<Option<TokenAmount>> {
        let bi = match bi {
            Some(bi) => bi.into_block_identifier(),
            None => BlockIdentifier::LastFinal,
        };

        let info = &self.client.get_account_info(acc, bi).await?.response;
        Ok(info.token_amount(&self.info.token_id))
    }

    /// Validates if the token can be minted. Validation fails if any of the
    /// following conditions is true:
    /// * The token is not mintable.
    /// * The token is in the paused state.
    /// * The provided amount's decimals differ from the token's decimals.
    ///
    /// # Arguments
    ///
    /// * `amount` - The amount of token to be minted.
    pub async fn validate_mint(&mut self, amount: TokenAmount) -> TokenResult<()> {
        // Fetching latest final token info
        self.update_token_info().await?;
        let state = self.info.token_state.decode_module_state()?;

        // Check if the token is mintable
        if !state.mintable.unwrap_or_default() {
            return Err(TokenError::NotMintable);
        }

        // Checks if the token is not paused
        if state.paused.unwrap_or_default() {
            return Err(TokenError::Paused);
        }

        // Check if amount to be minted has the same decimals as the token.
        if amount.decimals() != self.info.token_state.decimals {
            return Err(TokenError::InvalidTokenAmount);
        }

        Ok(())
    }

    /// Validates if the token can be burned. Validation fails if any of the
    /// following conditions is true:
    /// * The token is not burnable.
    /// * The token is in the paused state.
    /// * The provided [TokenAmount]'s decimals differ from the token's
    ///   decimals.
    /// * The account requesting the burn does not have sufficient amount of
    ///   tokens.
    ///
    /// # Arguments
    ///
    /// * `amount` - the amount of tokens to be burned.
    /// * `address` - the address of the account initializing the burn.
    pub async fn validate_burn(
        &mut self,
        amount: TokenAmount,
        address: AccountAddress,
    ) -> TokenResult<()> {
        // Fetching latest final token info
        self.update_token_info().await?;

        let state = self.info.token_state.decode_module_state()?;

        // Check if the token is burnable
        if !state.burnable.unwrap_or_default() {
            return Err(TokenError::NotBurnable);
        }

        // Checks if the token is not paused
        if state.paused.unwrap_or_default() {
            return Err(TokenError::Paused);
        }

        // Check if amount to be burned has the same decimals as the token.
        if amount.decimals() != self.info.token_state.decimals {
            return Err(TokenError::InvalidTokenAmount);
        }

        // Check if amount to be burned exceeds account's token amount in possesion
        let burnable_amount = self
            .balance_of(&address.into(), None::<BlockIdentifier>)
            .await?
            .ok_or(TokenError::InsufficientSupply)?;

        if burnable_amount.value() < amount.value() {
            return Err(TokenError::InsufficientSupply);
        }

        Ok(())
    }

    /// Validates if the token supports allow lists.
    pub async fn validate_allow_list_update(&mut self) -> TokenResult<()> {
        // Fetching latest final token info
        self.update_token_info().await?;

        // Checking if token supports allow lists
        let state = self.info.token_state.decode_module_state()?;
        if !state.allow_list.unwrap_or_default() {
            return Err(TokenError::NoAllowList);
        }
        Ok(())
    }

    /// Validates if the token supports deny lists.
    pub async fn validate_deny_list_update(&mut self) -> TokenResult<()> {
        // Fetching latest final token info
        self.update_token_info().await?;

        // Checking if token supports deny lists
        let state = self.info.token_state.decode_module_state()?;
        if !state.deny_list.unwrap_or_default() {
            return Err(TokenError::NoAllowList);
        }
        Ok(())
    }

    /// Validates a token transfer.
    /// The method checks for:
    /// * The token is not in the paused state.
    /// * All [`TokenAmount`]s for the transfer have the same decimals as the
    ///   token.
    /// * The sender has sufficient funds for all transfers.
    /// * Neither sender nor all recievers are in the tokens deny list.
    /// * The sender and all recievers are in the tokens allow list.
    ///
    /// # Arguments
    ///
    /// * `sender` - The account address of the sender.
    /// * `payload` - The token transfers that are about to be sent.
    pub async fn validate_transfer(
        &mut self,
        sender: AccountAddress,
        payload: Vec<TransferTokens>,
    ) -> TokenResult<()> {
        // Fetching latest final token info
        self.update_token_info().await?;

        let module_state = self.info.token_state.decode_module_state()?;

        // Check if the token is paused
        if module_state.paused.unwrap_or_default() {
        let client = self.client.clone();
        let token_id = &self.info.token_id;
        let decimals = self.info.token_state.decimals;
        let token_module_state = self.info.token_state.decode_module_state()?;
        Self::inner_validate_transfer(
            client,
            token_id,
            decimals,
            token_module_state,
            sender,
            payload,
        )
        .await
    }

    async fn inner_validate_transfer(
        mut client: impl AccountInfoFetch + Clone,
        token_id: &TokenId,
        decimals: u8,
        token_module_state: TokenModuleState,
        sender: AccountAddress,
        payload: Vec<TransferTokens>,
    ) -> TokenResult<()> {
        // check for pause
        if token_module_state.paused.unwrap_or_default() {
            return Err(TokenError::Paused);
        }

        // Validate all amounts
        if payload
            .iter()
            .any(|transfer| transfer.amount.decimals() != decimals)
        {
            return Err(TokenError::InvalidTokenAmount);
        }

        let sender_info = client
            .get_account_info(&sender.into(), BlockIdentifier::LastFinal)
            .await?
            .response;

        // Check the sender ballance
        let sender_balance = sender_info
            .token_amount(&token_id)
            .unwrap_or(TokenAmount::from_raw(0, decimals));

        let payload_total = TokenAmount::from_raw(
            payload
                .iter()
                .try_fold(0u64, |acc, x| acc.checked_add(x.amount.value()))
                .ok_or(TokenError::InvalidTokenAmount)?,
            decimals,
        );

        if payload_total > sender_balance {
            return Err(TokenError::InsufficientFunds);
        }

        // Check if token has no allow and deny lists
        if !module_state.allow_list.unwrap_or_default()
            && !module_state.deny_list.unwrap_or_default()
        {
            return Ok(());
        }

        // Check sender and recievers for allow and deny lists
        let mut accounts = Vec::with_capacity(payload.len() + 1);
        accounts.push(sender_info);

        let futures = payload.into_iter().map(|transfer| {
            let holder = transfer.recipient;
            let mut client = client.clone();
            async move {
                client
                    .get_account_info(&holder.into(), BlockIdentifier::LastFinal)
                    .await
            }
        });

        let recepients = futures::future::try_join_all(futures).await?;
        for recepient in recepients {
            let info = recepient.response;
            accounts.push(info);
        }

        for account in accounts {
            let token_state = account
                .tokens
                .into_iter()
                .find(|t| t.token_id == *token_id)
                .map(|t| t.state)
                .unwrap_or(TokenAccountState {
                    balance:      TokenAmount::from_raw(0, self.info.token_state.decimals),
                    module_state: None,
                });

            let account_module_state = token_state.decode_module_state()?;
            if module_state.deny_list.unwrap_or_default()
                && account_module_state.deny_list.unwrap_or_default()
            {
                return Err(TokenError::NotAllowed);
            }

            if module_state.allow_list.unwrap_or_default()
                && !account_module_state.allow_list.unwrap_or_default()
            {
                return Err(TokenError::NotAllowed);
            }
        }
        Ok(())
    }

    /// Initiates a transaction with a list of PLT operations for a given token.
    ///
    /// # Arguments
    ///
    /// * `signer` - A [`WalletAccount`] who's address is used as a sender and
    ///   keys as a signer.
    /// * `expiry` - The optional expiry time for the transaction.
    /// * `operations` - A list of protocol level token operations.
    /// * `meta` - The optional transaction metadata. Includes optional
    ///   expiration, nonce. Validation is ignored for this method.
    pub async fn send_operations(
        &mut self,
        signer: &WalletAccount,
        operations: TokenOperations,
        meta: Option<TransactionMetadata>,
    ) -> TokenResult<TransactionHash> {
        let TransactionMetadata { expiry, nonce, .. } = meta.unwrap_or_default();
        self.sign_and_send(signer, operations, expiry, nonce).await
    }

    /// Updates token's info to a last finilized block. The method can be
    /// ommited before calling the validation methods.
    pub async fn update_token_info(&mut self) -> TokenResult<()> {
        self.info = self
            .client
            .get_token_info(self.info.token_id.clone(), BlockIdentifier::LastFinal)
            .await?
            .response;
        Ok(())
    }

    /// Helper method containing the common logic related to signing and sending
    /// PLT operations.
    ///
    /// # Arguments
    ///
    /// * `signer` - A [`WalletAccount`] who's address is used as a sender and
    ///   keys as a signer.
    /// * `operations` - A list of protocol level token operations.
    /// * `expiry` - The expiry time for the transaction.
    /// * `nonce` - Option
    async fn sign_and_send(
        &mut self,
        signer: &WalletAccount,
        operations: TokenOperations,
        expiry: Option<TransactionTime>,
        nonce: Option<Nonce>,
    ) -> TokenResult<TransactionHash> {
        let expiry = expiry.unwrap_or(TransactionTime::seconds_after(self.default_expiry));

        let nonce = match nonce {
            Some(nonce) => nonce,
            None => {
                self.client
                    .get_next_account_sequence_number(&signer.address)
                    .await?
                    .nonce
            }
        };

        let token_id = self.info.token_id.clone();

        let transaction = send::token_update_operations(
            &signer,
            signer.address,
            nonce,
            expiry,
            token_id,
            operations,
        )?;
        let block_item = BlockItem::AccountTransaction(transaction);
        Ok(self.client.send_block_item(&block_item).await?)
    }
}

/// Helper trait for testing the transfer validation.
trait AccountInfoFetch {
    async fn get_account_info(
        &mut self,
        address: &AccountIdentifier,
        block: BlockIdentifier,
    ) -> endpoints::QueryResult<QueryResponse<AccountInfo>>;
}

impl AccountInfoFetch for Client {
    async fn get_account_info(
        &mut self,
        address: &AccountIdentifier,
        block: BlockIdentifier,
    ) -> endpoints::QueryResult<QueryResponse<AccountInfo>> {
        self.get_account_info(address, block).await
    }
}

#[cfg(test)]
mod tests {
    use concordium_base::{protocol_level_tokens::{CborHolderAccount, MetadataUrl}};

    use super::*;
    use std::{collections::{HashMap}, str::FromStr};

    #[derive(Debug, Clone)]
    struct MockClient {
        responses: HashMap<AccountAddress, QueryResponse<AccountInfo>>
    }

    impl MockClient {
        fn new() -> Self {
            Self {
                responses: HashMap::new(),
            }
        }
    }

    impl AccountInfoFetch for MockClient {
        async fn get_account_info(
            &mut self,
            address: &AccountIdentifier,
            _block: BlockIdentifier,
        ) -> endpoints::QueryResult<QueryResponse<AccountInfo>> {
            let AccountIdentifier::Address(address) = address else {
                return Err(QueryError::NotFound);
            };
            
            self.responses
                .get(address)
                .cloned()
                .ok_or(QueryError::NotFound)
        }
    }

    #[tokio::test]
    async fn pass_transfer_validation() {
        let client = MockClient::new();
        let token_id =
            TokenId::from_str("MockToken").expect("The Token Id must be able to created");
        let decimals = 8;
        let token_module_state = TokenModuleState {
            name:               "MockToken".into(),
            metadata:           MetadataUrl {
                url:              "SomeUrl".into(),
                checksum_sha_256: None,
                additional:       HashMap::new(),
            },
            governance_account: CborTokenHolder::Account(CborHolderAccount {
                coin_info: None,
                address:   AccountAddress::from_str("SomeAddress").expect("Must be valid Address"),
            }),
            allow_list:         None,
            deny_list:          None,
            mintable:           None,
            burnable:           None,
            paused:             None,
            additional:         HashMap::new(),
        };
        let sender =
            AccountAddress::from_str("address").expect("The account address must be valid");
        let payload = Vec::new();
        if let Err(err) = TokenClient::inner_validate_transfer(
            client,
            &token_id,
            decimals,
            token_module_state,
            sender,
            payload,
        )
        .await
        {
            panic!("validation failed! Reason: {err}");
        }
    }

    #[tokio::test]
    async fn fail_transfer_validation() {}
}
